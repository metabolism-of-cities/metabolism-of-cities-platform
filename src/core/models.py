from django.db import models

# Used for image resizing
from stdimage.models import StdImageField

# To indicate which site a record belongs to
from django.contrib.sites.models import Site
from django.contrib.sites.managers import CurrentSiteManager
from django.urls import reverse
from django.forms import ModelForm
from django.conf import settings
from markdown import markdown
from tinymce import HTMLField
import re
from unidecode import unidecode
from django.utils.text import slugify

from django.contrib.auth.models import User
from django.contrib.auth import get_user_model
User = get_user_model()

# To sanitize user input
import bleach
from django.utils.safestring import mark_safe

# For the JSON field
from django.contrib.postgres.fields import JSONField

# To get the geometry fields
from django.contrib.gis.db import models

# To be able to set an UUID
import uuid

# To be able to call just the filename in the file field
# Maybe move to def filename @property?
import os

# For youtube url parsing
from urllib.parse import urlparse, parse_qs

from django.utils import timezone
import pytz

# To get the total number of points
from django.db.models import Sum

# To get recently registered students in the course
import datetime

# To create the sample shapefile images
import geopandas
import contextily as ctx

from django.template.defaultfilters import filesizeformat
from django.db.models import Q

def get_date_range(start, end, months_only=False):

    if start and not end and months_only:
        return "Since " + start.strftime("%b %Y")
        
    if not start or not end:
        return None

    start_date = start.strftime("%b %Y") if months_only else start.strftime("%b %d, %Y")
    start_time = "00:00" if months_only else start.strftime("%H:%M")
    end_date = end.strftime("%b %Y") if months_only else end.strftime("%b %d, %Y")
    end_time = "00:00" if months_only else end.strftime("%H:%M")

    if start_date == end_date:
        if months_only:
            return start_date
        elif start_time == "00:00" and end_time == "00:00":
            return start_date
        elif start_time == end_time:
            return start.strftime("%b %d, %Y %H:%M")
        else:
            return start_date + " " + start_time + " - " + end_time
    else:
        if start.strftime("%Y%m") == end.strftime("%Y%m"):
            return start.strftime("%b") + " " + start.strftime("%d") + " - " + end.strftime("%d") + ", " + start.strftime("%Y")
        elif start_time != "00:00" and end_time != "00:00":
            return start.strftime("%b %d, %Y %H:%M") + " - " + end.strftime("%b %d, %Y %H:%M")
        elif start.strftime("%Y") == end.strftime("%Y"):
            if months_only:
                return start.strftime("%b") + " - " + end_date
            else:
                return start.strftime("%b %d") + " - " + end_date
        else:
            return start_date + " - " + end_date

# By default we really only want to see those records that are both public and not deleted
class PublicActiveRecordManager(models.Manager):
    def get_queryset(self):
        return super().get_queryset().filter(is_deleted=False, is_public=True)

# This returns those records that are private (a check around ownership needs to take place in the codebase)
# and that are not deleted
class PrivateRecordManager(models.Manager):
    def get_queryset(self):
        return super().get_queryset().filter(is_deleted=False)

class Tag(models.Model):
    name = models.CharField(max_length=255)
    description = models.TextField(null=True, blank=True)
    description_html = models.TextField(null=True, blank=True, help_text="Do not edit... auto-generated by the system")
    parent_tag = models.ForeignKey("self", on_delete=models.CASCADE, null=True, blank=True, related_name="children")
    hidden = models.BooleanField(db_index=True, default=False, help_text="Mark if tag is superseded/not yet approved/deactivated")
    include_in_glossary = models.BooleanField(db_index=True, default=False)
    belongs_to = models.ForeignKey("Record", on_delete=models.CASCADE, null=True, blank=True)
    is_deleted = models.BooleanField(default=False, db_index=True)
    is_public = models.BooleanField(default=True, db_index=True)
    icon = models.CharField(max_length=50, null=True, blank=True, help_text="Only include the icon name, not fa- classes --- see https://fontawesome.com/icons?d=gallery")
    color = models.CharField(max_length=30, null=True, blank=True)

    def __str__(self):
        return self.name

    def get_description(self):
        # The description_html field is already sanitized, according to the settings (see the save() function below)
        # So when we retrieve the html description we can trust this is safe, and will mark it as such
        # We avoid using |safe in templates -- to centralize the effort to sanitize input
        if self.description:
            return mark_safe(self.description_html)
        else:
            return ""

    def save(self, *args, **kwargs):
        if not self.description:
            self.description_html = None
        else:
            self.description_html = markdown(self.description)
        super().save(*args, **kwargs)

    @property
    def shortcode(self):
        "Returns abbreviation -- text between parenthesis -- if there is any"
        if "(" in self.name:
            s = self.name
            return s[s.find("(")+1:s.find(")")]
        else:
            return self.name

    class Meta:
        ordering = ["name"]

    objects_unfiltered = models.Manager()
    objects_include_private = PrivateRecordManager()
    objects = PublicActiveRecordManager()

class Record(models.Model):
    name = models.CharField(max_length=255)
    description = models.TextField(null=True, blank=True)
    description_html = models.TextField(null=True, blank=True, help_text="Do not edit... auto-generated by the system")
    image = StdImageField(upload_to="records", variations={"thumbnail": (480, 480), "large": (1280, 1024)}, blank=True, null=True)
    tags = models.ManyToManyField(Tag, blank=True)
    date_created = models.DateTimeField(auto_now_add=True)

    spaces = models.ManyToManyField("ReferenceSpace", blank=True)
    sectors = models.ManyToManyField("Sector", blank=True)
    subscribers = models.ManyToManyField("People", blank=True)
    materials = models.ManyToManyField("Material", blank=True)

    # We use soft deleted
    is_deleted = models.BooleanField(default=False, db_index=True)

    # Only public records are shown; non-public records are used for instance to manage records 
    # belonging to logged-in users only
    is_public = models.BooleanField(default=True, db_index=True)

    # These relationships are managed through separate tables, but they allow for prefetching to make 
    # the queries run much more efficiently
    child_of = models.ManyToManyField("self", through="RecordRelationship", through_fields=("record_child", "record_parent"), symmetrical=False, related_name="parent_of_child")
    parent_to = models.ManyToManyField("self", through="RecordRelationship", through_fields=("record_parent", "record_child"), symmetrical=False, related_name="child_of_parent")

    # We are going to delete this post-launch
    old_id = models.IntegerField(null=True, blank=True, db_index=True, help_text="Only used for the migration between old and new structure")

    meta_data = JSONField(null=True, blank=True)

    def __str__(self):
        return self.name

    def get_absolute_url(self):
        if hasattr(self, "dataset"):
            url = reverse("data:dataset", args=[self.id])
        elif hasattr(self, "libraryitem"):
            url = reverse("library:item", args=[self.id])
        elif hasattr(self, "news"):
            url = reverse("core:news", args=[self.news.slug])
        elif hasattr(self, "event"):
            url = reverse("core:event", args=[self.event.slug])
        elif hasattr(self, "video"):
            url = reverse("multimedia:video", args=[self.id])
        elif hasattr(self, "course"):
            url = reverse("education:course", args=[self.course.slug])
        elif hasattr(self, "project"):
            url = self.project.get_website()
        else:
            return None
        first_chars = url[:5]
        if first_chars == "/http":
            url = url[1:]
        return url

    def get_methodologies(self):
        self.tags.filter(parent_tag__id=318)

    def get_markdown_description(self):
        return markdown(self.description) if self.description else None

    def authors(self):
        return People.objects.filter(parent_list__record_child=self, parent_list__relationship__id=4)

    def funders(self):
        return Record.objects.filter(parent_list__record_child=self, parent_list__relationship__id=5)

    def author(self):
        try:
            return People.objects.filter(parent_list__record_child=self, parent_list__relationship__id=4)[0]
        except:
            return None

    def get_description(self):
        # The description_html field is already sanitized, according to the settings (see the save() function below)
        # So when we retrieve the html description we can trust this is safe, and will mark it as such
        # We avoid using |safe in templates -- to centralize the effort to sanitize input
        if self.description:
            return mark_safe(self.description_html)
        else:
            return ""

    def save(self, *args, **kwargs):
        if not self.description:
            self.description_html = None
        elif self.meta_data and "format" in self.meta_data and self.meta_data["format"] != "markdown":
            if self.meta_data["format"] == "markdown_html":
                # Here it wouldn't hurt to apply bleach and take out unnecessary tags
                self.description_html = markdown(self.description)
            elif self.meta_data["format"] == "html":
                # Here it wouldn't hurt to apply bleach and take out unnecessary tags
                self.description_html = self.description
        else:
            self.description_html = markdown(bleach.clean(self.description))
            # In normal Markdown convention, a single newline will NOT be converted to <br>
            # However this is not how regular textareas work, and people are expecting this to work
            # so we add these <br>s. Ideally we would avoid <p>hello</p><br><p>newline</p> but 
            # for now that's the additional consequence -- doesn't seem to be a really visible impact anyways
            self.description_html = self.description_html.replace("\n", "<br>")
        super().save(*args, **kwargs)

    objects_unfiltered = models.Manager()
    objects_include_private = PrivateRecordManager()
    objects = PublicActiveRecordManager()

def upload_directory(instance, filename):
    # file will be uploaded to MEDIA_ROOT/uuid/<filename>
    directory = "uploads/"
    if hasattr(instance, "attached_to"):
        parent = instance.attached_to
    elif hasattr(instance, "attached"):
        parent = instance.attached
    else:
        parent = instance
    object_type = parent.__class__.__name__
    object_type = object_type.lower()
    directory += object_type + "/"
    if object_type == "libraryitem":
        sub_directory = parent.type.name
        sub_directory = sub_directory.lower()
        directory += sub_directory + "/"
    if parent.meta_data and "uuid" in parent.meta_data:
        directory += parent.meta_data["uuid"] + "/"
    return directory + filename

class Document(Record):
    file = models.FileField(null=True, blank=True, upload_to=upload_directory, max_length=255)
    attached_to = models.ForeignKey(Record, on_delete=models.CASCADE, null=True, blank=True, related_name="attachments")

    objects_unfiltered = models.Manager()
    objects_include_private = PrivateRecordManager()
    objects = PublicActiveRecordManager()

    def get_size(self):
        file = self.file if self.file else self.image
        try:
            return filesizeformat(file.size) if file else None
        except:
            return 0

    def get_url(self):
        return self.file.url if self.file else self.image.url

class ProjectType(models.Model):
    name = models.CharField(max_length=255)
    icon = models.CharField(max_length=50, help_text="Only include the icon name, not fa- classes --- see https://fontawesome.com/icons?d=gallery")

    def __str__(self):
        return self.name

class Project(Record):
    type = models.ForeignKey(ProjectType, on_delete=models.CASCADE, null=True, blank=True)
    contributor_page = HTMLField(null=True, blank=True)
    support_page = HTMLField(null=True, blank=True)
    start_date = models.DateField(blank=True, null=True)
    end_date = models.DateField(blank=True, null=True)
    STATUS = (
        ("planned", "Planned"),
        ("ongoing", "Ongoing"),
        ("finished", "Finished"),
        ("cancelled", "Cancelled"),
    )
    status = models.CharField(max_length=20, choices=STATUS, default="ongoing")
    has_subsite = models.BooleanField(default=False)
    slug = models.SlugField(max_length=50, unique=True, blank=True, null=True)
    url = models.URLField(max_length=255, null=True, blank=True)
    screenshot = StdImageField(upload_to="project_screenshots", variations={"thumbnail": (350, 350), "medium": (510, 510), "large": (1280, 1024)}, blank=True, null=True, help_text="1280x1024 is best - do not include browser tabs/menus")
    summary_sentence = models.CharField(max_length=255, null=True, blank=True, help_text="Describe the project in a single sentence")

    def get_slug(self):
        if self.slug:
            return self.slug
        else:
            return "core"

    def get_absolute_url(self):
        return reverse("core:project", args=[self.slug])

    def get_website(self):
        if self.url:
            return self.url
        elif self.has_subsite:
            return "/" + self.slug + "/"
        else:
            return reverse("core:project", args=[self.slug])

    def get_content(self):
        return markdown(self.description) if self.type == "markdown" else self.description

    def get_image(self):
        if self.image:
            return self.image
        elif self.design.logo:
            return self.design.logo
        else:
            return None

    class Meta:
        ordering = ["name"]

    def get_dates(self):
        return get_date_range(self.start_date, self.end_date)
    
    def get_dates_months(self):
        return get_date_range(self.start_date, self.end_date, True)

    objects_unfiltered = models.Manager()
    objects_include_private = PrivateRecordManager()
    objects = PublicActiveRecordManager()

class PublicProject(Record):
    full_name = models.CharField(max_length=255, null=True, blank=True)
    email = models.EmailField(null=True, blank=True)
    url = models.URLField(max_length=255, null=True, blank=True)
    site = models.ForeignKey(Site, on_delete=models.CASCADE)
    target_finish_date = models.CharField(max_length=255, null=True, blank=True)
    start_date = models.DateField(blank=True, null=True)
    end_date = models.DateField(blank=True, null=True)
    STATUS = (
        ("planned", "Planned"),
        ("ongoing", "Ongoing"),
        ("finished", "Finished"),
        ("cancelled", "Cancelled"),
    )
    status = models.CharField(max_length=20, choices=STATUS, default="ongoing")
    part_of_project = models.ForeignKey(Project, on_delete=models.CASCADE, null=True, blank=True)

    def get_dates(self):
        return get_date_range(self.start_date, self.end_date)
    
    def get_dates_months(self):
        return get_date_range(self.start_date, self.end_date, True)

    def get_absolute_url(self):
        return reverse("community:project", args=[self.id])

    objects_unfiltered = models.Manager()
    objects_include_private = PrivateRecordManager()
    objects = PublicActiveRecordManager()

class News(Record):
    date = models.DateField()
    objects = models.Manager()
    slug = models.SlugField(max_length=255)
    projects = models.ManyToManyField(Project)
    include_in_timeline = models.BooleanField(default=False)

    def get_absolute_url(self):
        if self.projects.count() > 0:
            return self.projects.all()[0].get_website() + "news/" + self.slug + "/"
        else:
            return reverse("community:news", args=[self.slug])

    def authors(self):
        return People.objects.filter(parent_list__record_child=self, parent_list__relationship__id=4)

    def save(self, *args, **kwargs):
        self.slug = slugify(unidecode(self.name))
        super().save(*args, **kwargs)

    class Meta:
        verbose_name_plural = "news"
        ordering = ["-date", "-id"]

    objects_unfiltered = models.Manager()
    objects_include_private = PrivateRecordManager()
    objects = PublicActiveRecordManager()

class Blog(Record):
    date = models.DateField()
    site = models.ForeignKey(Site, on_delete=models.CASCADE)
    objects = models.Manager()
    on_site = CurrentSiteManager()
    slug = models.SlugField(max_length=255)
    class Meta:
        ordering = ["-date", "-id"]
    def get_absolute_url(self):
        return reverse("blog", args=[self.id])
    def save(self, *args, **kwargs):
        self.slug = slugify(unidecode(self.name))
        super().save(*args, **kwargs)

    objects_unfiltered = models.Manager()
    objects_include_private = PrivateRecordManager()
    objects = PublicActiveRecordManager()

class Organization(Record):
    url = models.CharField(max_length=255, null=True, blank=True)
    twitter = models.CharField(max_length=255, null=True, blank=True)
    linkedin = models.CharField(max_length=255, null=True, blank=True)
    researchgate = models.CharField(max_length=255, null=True, blank=True)
    email = models.EmailField(null=True, blank=True)
    slug = models.SlugField(max_length=255)
    ORG_TYPE = (
        ("academic", "Research Institution"),
        ("universities", "Universities"),
        ("city_government", "City Government"),
        ("regional_government", "Regional Government"),
        ("national_government", "National Government"),
        ("statistical_agency", "Statistical Agency"),
        ("private_sector", "Private Sector"),
        ("publisher", "Publishers"),
        ("journal", "Journal"),
        ("society", "Academic Society"),
        ("ngo", "NGO"),
        ("funding_program", "Funding Programme"),
        ("other", "Other"),
    )
    type = models.CharField(max_length=20, choices=ORG_TYPE)

    def save(self, *args, **kwargs):
        self.slug = slugify(unidecode(self.name))
        if self.email:
            self.email=self.email.lower()
        if self.twitter:
            try:
                url = self.twitter
                if url[:4] == "http":
                    self.twitter = url.rsplit("/", 1)[-1]
                elif url[:1] == "@":
                    self.twitter = url[1:]
            except:
                pass
        super().save(*args, **kwargs)

    def get_absolute_url(self):
        return reverse("library:journal", args=[self.slug])

    def publications(self):
        # To get all the publications we'll get the LibraryItems that are a child
        # record that are linked to this organization (e.g. journal or publishing house) as a parent
        return LibraryItem.objects.select_related("type").filter(child_list__record_parent=self, child_list__relationship__id=2)

    objects_unfiltered = models.Manager()
    objects_include_private = PrivateRecordManager()
    objects = PublicActiveRecordManager()

    class Meta:
        ordering = ["name"]

# This defines the relationships that may exist between users and records, or between records
# For instance authors, admins, employee, funder
class Relationship(models.Model):
    name = models.CharField(max_length=255)
    label = models.CharField(max_length=255)
    slug = models.SlugField(max_length=20, db_index=True, unique=True, blank=True, null=True, help_text="Should only be set for permissions, and should only be modified by the programming team")
    description = models.TextField(null=True, blank=True)
    is_permission = models.BooleanField(default=False, help_text="Mark if this relationship is about giving people permissions in the system")
    def __str__(self):
        return self.label

# This defines a particular relationship between two records.
# For instance: Record 100 (company AA) has the relationship "Funder" of Record 104 (Project BB)
# It will always be in the form of RECORD_PARENT is RELATIONSHIP of RECORD_CHILD
# Wiley is the publisher of the JIE. Wiley = record_parent; JIE = record_child
# Fulano is the author of Paper A. Fulano = record_parent; Paper A = record_child 
class RecordRelationship(models.Model):
    record_parent = models.ForeignKey(Record, on_delete=models.CASCADE, related_name="parent_list")
    relationship = models.ForeignKey(Relationship, on_delete=models.CASCADE)
    record_child = models.ForeignKey(Record, on_delete=models.CASCADE, related_name="child_list")
    date_created = models.DateTimeField(auto_now_add=True, null=True, blank=True)

    def __str__(self):
        return str(self.record_parent) + ' ' + str(self.relationship.label) + ' ' + str(self.record_child)

    class Meta:
        verbose_name_plural = "relationship manager"
        verbose_name = "relationship manager"
        unique_together = ["record_parent", "relationship", "record_child"]

class SocialMediaPlatform(models.Model):
    name = models.CharField(max_length=255)
    icon = models.CharField(max_length=30)

    def __str__(self):
        return self.name

class SocialMedia(models.Model):
    name = models.CharField(max_length=255)
    record = models.ForeignKey(Record, on_delete=models.CASCADE, null=True, blank=True)
    STATUS = [
        ("draft", "Draft"),
        ("discarded", "Discarded"),
        ("ready", "Ready for publication"),
        ("published", "Published"),
    ]
    status = models.CharField(max_length=20, blank=True, null=True, choices=STATUS, default="draft")
    date = models.DateTimeField(null=True, blank=True)
    description = models.TextField(null=True, blank=True)
    response = models.TextField(null=True, blank=True)
    image = StdImageField(upload_to="socialmedia", variations={"thumbnail": (480, 480), "large": (1280, 1024)}, blank=True, null=True)
    campaign = models.ForeignKey(Tag, on_delete=models.CASCADE, limit_choices_to={"parent_tag_id": 927})
    platforms = models.ManyToManyField(SocialMediaPlatform)

    def __str__(self):
        return self.name

class Event(Record):
    EVENT_TYPE = [
        ("conference", "Conference"),
        ("hackathon", "Hackathon"),
        ("workshop", "Workshop"),
        ("seminar", "Seminar"),
        ("summerschool", "Summer School"),
        ("other", "Other"),
        ("training_outreach", "Training and Outreach"),
    ]
    type = models.CharField(max_length=20, blank=True, null=True, choices=EVENT_TYPE)
    url = models.URLField(max_length=255, null=True, blank=True)
    location = models.CharField(max_length=255, null=True, blank=True)
    start_date = models.DateTimeField(null=True, blank=True)
    end_date = models.DateTimeField(null=True, blank=True)
    slug = models.SlugField(max_length=255)
    projects = models.ManyToManyField(Project)

    class Meta:
        ordering = ["-start_date", "-id"]

    def get_absolute_url(self):
        if self.projects.count() > 0:
            return self.projects.all()[0].get_website() + "events/" + str(self.id) + "/" + self.slug + "/"
        else:
            return reverse("community:event", args=[self.id, self.slug])

    def get_dates(self):
        return get_date_range(self.start_date, self.end_date)

    def save(self, *args, **kwargs):
        self.slug = slugify(unidecode(self.name))
        super().save(*args, **kwargs)

    def get_status(self):
        try:
            today = timezone.now()
            if self.end_date < today:
                return "finished"
            elif self.start_date <= today and self.end_date >= today:
                return "active"
            else:
                return "upcoming"
        except:
            return "upcoming"

    objects_unfiltered = models.Manager()
    objects_include_private = PrivateRecordManager()
    objects = PublicActiveRecordManager()

class People(Record):
    firstname = models.CharField(max_length=255, null=True, blank=True)
    lastname = models.CharField(max_length=255, null=True, blank=True)
    affiliation = models.CharField(max_length=255,null=True, blank=True)
    email = models.EmailField(max_length=255, null=True, blank=True)
    email_public = models.BooleanField(default=False)
    website = models.CharField(max_length=255, null=True, blank=True)
    twitter = models.CharField(max_length=255, null=True, blank=True)
    google_scholar = models.CharField(max_length=255, null=True, blank=True)
    orcid = models.CharField(max_length=255, null=True, blank=True)
    researchgate = models.CharField(max_length=255, null=True, blank=True)
    linkedin = models.CharField(max_length=255, null=True, blank=True)
    research_interests = models.TextField(null=True, blank=True)
    PEOPLE_STATUS = (
        ("active", "Active"),
        ("retired", "Retired"),
        ("deceased", "Deceased"),
        ("inactive", "Inactive"),
        ("pending", "Pending Review"),
    )
    status = models.CharField(max_length=8, choices=PEOPLE_STATUS, default="active")
    user = models.OneToOneField(User, null=True, blank=True, on_delete=models.CASCADE)
    badges = models.ManyToManyField("Badge", blank=True)

    def __str__(self):
        return self.name

    def get_absolute_url(self):
        return reverse("community:person", args=[self.id])

    def points(self):
        points = Work.objects_unfiltered.filter(assigned_to=self, status=Work.WorkStatus.COMPLETED).aggregate(total=Sum("workactivity__points"))
        return points["total"]

    def avatar(self):
        if self.image and self.image != "":
            return mark_safe('<img class="avatar" src="' + self.image.thumbnail.url + '" alt="' + self.name + '" title="' + self.name + '">')
        else:
            return mark_safe('<div title="' + self.name + '" class="avatar letter">' + self.name[:1] + '</div>')

    def get_photo(self):
        if self.image:
            return self.image
        else:
            photo = Photo.objects.get(pk=33476)
            return photo.image

    class Meta:
        verbose_name_plural = "people"
        ordering = ["name"]

    def save(self, *args, **kwargs):
        if self.email:
            self.email=self.email.lower()
        if self.twitter:
            try:
                url = self.twitter
                if url[:4] == "http":
                    self.twitter = url.rsplit("/", 1)[-1]
                elif url[:1] == "@":
                    self.twitter = url[1:]
            except:
                pass
        super(People, self).save(*args, **kwargs)

    objects_unfiltered = models.Manager()
    objects_include_private = PrivateRecordManager()
    objects = PublicActiveRecordManager()

# We use this to keep a version history of records (which is done for some, not all)
# We save the record name/title and the description, which allows us to go 
# back in time when needed / see a revision history
# It also allows for people to draft a NEW version and review this first before going live
class RecordHistory(models.Model):

    class Status(models.IntegerChoices):
        HISTORIC = 1, "Historic version"
        DRAFT = 2, "New draft version (unapproved)"
        REJECTED = 3, "Rejected version"

    status = models.IntegerField(choices=Status.choices, db_index=True)
    name = models.CharField(max_length=255)
    description = HTMLField(null=True, blank=True)
    date_created = models.DateTimeField(auto_now_add=True)
    record = models.ForeignKey(Record, on_delete=models.CASCADE, related_name="history")
    people = models.ForeignKey(People, on_delete=models.CASCADE, related_name="record_history")

    class Meta:
        ordering = ["-id"]

class Webpage(Record):
    TYPE = [
        ("html", "HTML"),
        ("markdown", "Markdown"),
        ("markdown_html", "Markdown and HTML"),
    ]
    type = models.CharField(max_length=13, choices=TYPE, default="markdown")
    slug = models.CharField(db_index=True, max_length=100)
    part_of_project = models.ForeignKey(Project, on_delete=models.CASCADE, null=True, blank=True, related_name="webpages")

    objects_unfiltered = models.Manager()
    objects_include_private = PrivateRecordManager()
    objects = PublicActiveRecordManager()

    def get_absolute_url(self):
        return self.slug

    def get_content(self):
        if self.type == "markdown":
            return bleach.clean(markdown(self.description))
        elif self.type == "html":
            return self.description
        elif self.type == "markdown_html":
            return markdown(self.description)

    class Meta:
        constraints = [
            models.UniqueConstraint(fields=["part_of_project", "slug"], name="project_slug")
        ]
        ordering = ["name"]

class WebpageDesign(models.Model):
    webpage = models.OneToOneField(Record, on_delete=models.CASCADE, primary_key=True)
    HEADER = [
        ("inherit", "No custom header - use the project header"),
        ("full", "Full header with title and subtitle"),
        ("small", "Small header; menu only"),
        ("image", "Image underneath menu"),
    ]
    header = models.CharField(max_length=7, choices=HEADER, default="full")
    header_title = models.CharField(max_length=100, null=True, blank=True)
    header_subtitle = models.CharField(max_length=255, null=True, blank=True)
    header_image = StdImageField(upload_to="header_image", variations={"thumbnail": (480, 480), "large": (1280, 1024), "huge": (2560, 1440)}, blank=True, null=True)
    custom_css = models.TextField(null=True, blank=True)
    def __str__(self):
        return self.webpage.name

class ProjectDesign(models.Model):
    project = models.OneToOneField(Project, on_delete=models.CASCADE, primary_key=True, related_name="design")
    HEADER = [
        ("full", "Full header with title and subtitle"),
        ("small", "Small header; menu only"),
        ("image", "Image underneath menu"),
    ]
    header = models.CharField(max_length=6, choices=HEADER, default="full")
    HEADER_COLOR = [
        ("dark", "Dark background, light text"),
        ("light", "Light background, dark text"),
    ]
    header_color = models.CharField(max_length=6, choices=HEADER_COLOR, default="dark")
    logo = models.FileField(null=True, blank=True, upload_to="logos")
    custom_css = models.TextField(null=True, blank=True)
    back_link = models.BooleanField(default=True)
    def __str__(self):
        return self.project.name

class ForumTopic(Record):
    last_update = models.ForeignKey("Message", on_delete=models.SET_NULL, null=True, blank=True)
    part_of_project = models.ForeignKey(Project, on_delete=models.CASCADE, null=True, blank=True)
    parent = models.ForeignKey(Record, on_delete=models.CASCADE, null=True, blank=True, related_name="forum_topics")
    is_starred = models.NullBooleanField(default=False)
    parent_url = models.URLField(null=True, blank=True, db_index=True)

    def posters(self):
        return People.objects.filter(message_list__parent=self).distinct()

    def get_absolute_url(self):
        if self.parent_url:
            return self.parent_url
        else:
            return reverse("core:forum", args=[self.id])

    def get_full_url(self):
        # Sometimes we want to create a full URL, combining the 
        # project website with a path that /starts/with/a/slash
        # so in that case we want to ensure the https://project.com/ 
        # website doesn't end with a slash
        if self.parent_url:
            if not self.part_of_project:
                return self.parent_url
            else:
                project_site = self.part_of_project.get_website()
                last_char = project_site[-1]
                if last_char == "/":
                    project_site = project_site[:-1]
                return project_site + self.parent_url
        else:
            return reverse("core:forum", args=[self.id])

    class Meta:
        ordering = ["-is_starred", "-last_update__date_created"]

class Message(Record):
    parent = models.ForeignKey(Record, on_delete=models.CASCADE, null=True, blank=True, related_name="messages")
    posted_by = models.ForeignKey(People, on_delete=models.CASCADE, null=True, blank=True, related_name="message_list")

    def save(self, *args, **kwargs):
        super().save(*args, **kwargs)
        # If this is a forum or work-related message (most of them are) then we need to record
        # in the parent what the latest mesage is (this is for sorting, filtering etc)
        try:
            if hasattr(self.parent, "forumtopic"):
                parent = self.parent.forumtopic
            elif hasattr(self.parent, "work"):
                parent = self.parent.work
            if parent:
                check_last_update = Message.objects.filter(parent=self.parent).order_by("-date_created")
                if check_last_update:
                    parent.last_update = check_last_update[0]
                    parent.save()
        except Exception as e:
            pass

    def get_absolute_url(self):
        try:
            if hasattr(self.parent, "forumtopic"):
                return reverse("core:forum", args=[self.parent.id])
            elif hasattr(self.parent, "work"):
                return reverse("core:work_item", args=[self.parent.id])
            else:
                return None
        except:
            return None

    class Meta:
        ordering = ["date_created"]

    objects_unfiltered = models.Manager()
    objects_include_private = PrivateRecordManager()
    objects = PublicActiveRecordManager()

class License(models.Model):
    name = models.CharField(max_length=255)
    url = models.CharField(max_length=255, null=True, blank=True)
    
    def __str__(self):
        return self.name

    class Meta:
        ordering = ["name"]

class LibraryItemType(models.Model):
    name = models.CharField(max_length=255)
    icon = models.CharField(max_length=255, null=True, blank=True)
    GROUP = (
        ("academic", "Academic"),
        ("theses", "Theses"),
        ("reports", "Reports"),
        ("multimedia", "Multimedia"),
    )
    group = models.CharField(max_length=20, choices=GROUP, null=True, blank=True)

    def __str__(self):
        return self.name
    class Meta:
        ordering = ["name"]

class LibraryItem(Record):
    LANGUAGES = (
        ("EN", "English"),
        ("ES", "Spanish"),
        ("CH", "Chinese"),
        ("FR", "French"),
        ("GE", "German"),
        ("NL", "Dutch"),
        ("PT", "Portuguese"),
        ("OT", "Other"),
    )
    language = models.CharField(max_length=2, choices=LANGUAGES, default="EN", null=True, blank=True)
    title_original_language = models.CharField(max_length=255, blank=True, null=True)
    author_list = models.TextField(null=True, blank=True)
    author_citation = models.TextField(null=True, blank=True)
    bibtex_citation = models.TextField(null=True, blank=True)
    type = models.ForeignKey(LibraryItemType, on_delete=models.CASCADE)
    is_part_of = models.ForeignKey("self", on_delete=models.SET_NULL, null=True, blank=True, related_name="children")
    year = models.PositiveSmallIntegerField(null=True, blank=True)
    abstract_original_language = models.TextField(null=True, blank=True)
    date_added = models.DateTimeField(null=True, blank=True, auto_now_add=True)
    file = models.FileField(null=True, blank=True, upload_to="library")
    url = models.CharField(max_length=500, null=True, blank=True)
    file_url = models.URLField(null=True, blank=True)
    open_access = models.NullBooleanField(null=True, blank=True)
    doi = models.CharField(max_length=255, null=True, blank=True)
    isbn = models.CharField(max_length=255, null=True, blank=True)
    comments = models.TextField(null=True, blank=True)
    license = models.ForeignKey(License, on_delete=models.CASCADE, null=True, blank=True)

    STATUS = (
        ("pending", "Pending"),
        ("active", "Active"),
        ("deleted", "Deleted"),
    )
    # We will delete this after we inserted appropriate work tickets
    status = models.CharField(max_length=8, choices=STATUS, db_index=True, null=True, blank=True, help_text="Old field, do not use")
    #processes = models.ManyToManyField("staf.Process", blank=True, limit_choices_to={"slug__isnull": False})
    #materials = models.ManyToManyField("staf.Material", blank=True)

    def __str__(self):
        return self.name if self.name else "Untitled " + self.type.name

    class Meta:
        ordering = ["-year", "name"]

    def get_absolute_url(self):
        if self.type_id == 31:
            # Videos are opened in the multimedia library
            return reverse("multimedia:video", args=[self.id])
        elif self.type_id == 33:
            # Data viz are opened in the multimedia library
            return reverse("multimedia:dataviz", args=[self.id])
        elif self.type_id == 24:
            # Podcasts are opened in the multimedia library
            return reverse("multimedia:podcast", args=[self.id])
        elif self.type_id == 10 or self.type_id == 40:
            # Datasets and shapefiles are opened in the data hub
            return reverse("data:dataset", args=[self.id])
        else:
            return reverse("library:item", args=[self.id])

    def get_canonical_website(self):
        if self.type_id == 31 or self.type_id == 33 or self.type_id == 24:
            return "https://multimedia.metabolismofcities.org"
        elif self.type_id == 10 or self.type_id == 40:
            return "https://data.metabolismofcities.org"
        else:
            return "https://library.metabolismofcities.org"

    def get_full_url(self):
        # Depending on which subsite we are on, the absolute url may
        # already or may not yet include the HTTP part, so here we try to 
        # make sure we always have the full URL
        url = self.get_absolute_url()
        first_chars = url[:4]
        if first_chars == "/htt":
            return url[1:]
        elif first_chars == "http":
            return url
        else:
            return self.get_canonical_website() + url

    def get_edit_link(self):
        if self.type_id == 31:
            # Videos are opened in the multimedia library
            return "/admin/core/video/" + str(self.id) + "/change/"
        else:
            return "/admin/core/libraryitem/" + str(self.id) + "/change/"

    def publisher(self):
        list = Organization.objects.filter(parent_list__record_child=self, parent_list__relationship__id=2)
        return list[0] if list else None

    def producer(self):
        list = Organization.objects.filter(parent_list__record_child=self, parent_list__relationship__id=3)
        return list[0] if list else None

    def uploader(self):
        list = People.objects.filter(parent_list__record_child=self, parent_list__relationship__id=11)
        return list[0] if list else None

    # The 'author_list' part will be highly varied... some contain Firstname Lastname, Firstname Lastname 
    # others contain Lastname, Firstname and Lastname, Firstname
    # others contain Firstname Lastname; Firstname Lastname; etc.
    # This script tries to get the author_list ready for in-text citation (up to two authors; adding et al 
    # if there are more). 
    def get_author_citation(self):
        if self.author_citation:
            return self.author_citation
        elif self.author_list:
            author_array = []
            author_list = self.author_list
            if " and " in author_list:
                authors = author_list.split(" and ")
                for each in authors:
                    if "," in each:
                        lastname = each.split(",", 1)[0]
                    else:
                        lastname = each.rpartition(" ")[2]
                    author_array.append(lastname)
            elif ";" in author_list:
                authors = author_list.split(";")
                for each in authors:
                    if "," in each:
                        lastname = each.split(",", 1)[0]
                    else:
                        lastname = each.rpartition(" ")[2]
                    author_array.append(lastname)
            elif "," in author_list:
                authors = author_list.split(",")
                for each in authors:
                    lastname = each.rpartition(" ")[2]
                    author_array.append(lastname)
            else:
                # One option is to show JUST the lastname, but in practice it's more likely 
                # that this is the name of an entity like "City of Cape Town", so let's do the 
                # whole name instead
                # lastname = author_list.rpartition(" ")[2]
                author_array.append(author_list)
            if len(author_array) == 1:
                return author_array[0]
            elif len(author_array) == 2:
                return author_array[0] + " and " + author_array[1]
            elif len(author_array) > 2:
                return mark_safe(bleach.clean(author_array[0]) + " <em>et al.</em>")
            else:
                return ""
        else:
            return ""

    def get_full_citation(self):
        return mark_safe("<em>" + self.name + "</em>, " + self.get_author_citation() + ", " + str(self.year))
        
    def reference_spaces(self):
        return ReferenceSpace.objects.filter(child_list__record_parent=self, child_list__relationship_id=30)

    def embed(self):
        if "ted" in self.url:
            try:
                url = self.url
                url = url.split("/")
                url = url[-1]
                return f'<iframe class="video-embed video-ted" src="https://embed.ted.com/talks/{url}" frameborder="0" scrolling="no" allowfullscreen></iframe>'
            except:
                return "<div class='alert alert-warning'>Embedded video unavailable. <a href='" + self.url + "'>Click here to view the video</a></div>"

    def get_size(self):
        try:
            return filesizeformat(self.file.size) if self.file else None
        except:
            return 0

    def get_shapefile_plot(self):
        try:
            return settings.MEDIA_URL + self.meta_data["shapefile_plot"]
        except:
            return None

    objects_unfiltered = models.Manager()
    objects_include_private = PrivateRecordManager()
    objects = PublicActiveRecordManager()

    def create_shapefile_plot(self):
        if not self.meta_data:
            self.meta_data = {}
        try:
            files = self.attachments.filter(Q(file__iendswith=".shp")|Q(file__iendswith=".shx")|Q(file__iendswith=".dbf")|Q(file__iendswith=".prj"))
            print(files.count())
            if files.count() < 4:
                self.meta_data["shapefile_plot_error"] = "No shapefile found! Make sure all required files are uploaded (.shp, .shx, .dbf, .prj)."
            elif files.count() > 4:
                self.meta_data["shapefile_plot_error"] = "Too many files found! Make sure one file is uploaded for all four required types (.shp, .shx, .dbf, .prj)."
            else:
                file = files.filter(file__iendswith=".shp")
                if not file:
                    self.meta_data["shapefile_plot_error"] = "No shapefile (.shp) found!"
                else:
                    file = file[0]
                    filename = settings.MEDIA_ROOT + "/" + file.file.name
                    df = geopandas.read_file(filename)
                    df = df.to_crs(epsg=3857)
                    ax = df.plot(alpha=0.5, edgecolor="k")
                    ctx.add_basemap(ax)
                    fig = ax.get_figure()
                    output = upload_directory(self, "shapefile_plot.png")
                    fig.savefig(settings.MEDIA_ROOT + "/" + output)
                    self.meta_data["shapefile_plot"] = output
                    self.meta_data["shapefile_plot_error"] = None
            self.save()
        except Exception as e:
            self.meta_data["shapefile_plot_error"] = str(e)
            self.save()

    def save(self, *args, **kwargs):
        if self.doi:
            try:
                url = self.doi
                if url[:4] == "http":
                    self.doi = url.rsplit("/", 1)[-1]
            except:
                pass
        super(LibraryItem, self).save(*args, **kwargs)

class Video(LibraryItem):
    embed_code = models.CharField(max_length=20, null=True, blank=True)
    date = models.DateField(blank=True, null=True)
    duration = models.PositiveSmallIntegerField(null=True, blank=True, help_text="Duration in minutes")
    VIDEO_SITES = [
        ("youtube", "Youtube"),
        ("vimeo", "Vimeo"),
        ("ted", "TED"),
        ("other", "Other"),
    ]
    video_site = models.CharField(max_length=14, choices=VIDEO_SITES)
    def get_absolute_url(self):
        return reverse("multimedia:video", args=[self.id])

    def get_embed_code(self):
        url = self.url
        if not url:
            # This is for ascus only, we should fix / remove later
            url = self.file_url
        if url:
            # Thank you https://stackoverflow.com/questions/4356538/how-can-i-extract-video-id-from-youtubes-link-in-python
            # Examples:
            # - http://youtu.be/SA2iWivDJiE
            # - http://www.youtube.com/watch?v=_oPAwA_Udwc&feature=feedu
            # - http://www.youtube.com/embed/SA2iWivDJiE
            # - http://www.youtube.com/v/SA2iWivDJiE?version=3&amp;hl=en_US
            query = urlparse(url)
            if query.hostname == "youtu.be": return query.path[1:]
            if query.hostname in ("www.youtube.com", "youtube.com"):
                if query.path == "/watch": return parse_qs(query.query)["v"][0]
                if query.path[:7] == "/embed/": return query.path.split("/")[2]
                if query.path[:3] == "/v/": return query.path.split("/")[2]
                return None

    def embed(self):
        if self.video_site == "youtube":
            code = self.get_embed_code()
            return f'<iframe class="video-embed youtube-video" src="https://www.youtube.com/embed/{code}?rel=0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>'
        elif self.url and "ted.com" in self.url:
            try:
                url = self.url
                url = url.split("/")
                url = url[-1]
                return f'<iframe class="video-embed ted-video" title="ted-player" src="https://embed.ted.com/talks/{url}" frameborder="0" allowfullscreen></iframe>'
            except:
                return "<div class='alert alert-warning'>Embedded video unavailable. <a href='" + self.url + "'>Click here to view the video</a></div>"
        elif self.video_site == "vimeo":
            return f'<iframe class="video-embed vimeo-video" title="vimeo-player" src="https://player.vimeo.com/video/{self.embed_code}" frameborder="0" allowfullscreen></iframe>'
        elif self.attachments.all():
            try:
                file = self.meta_data["video_settings"]["compiled_video"]
                file = settings.MEDIA_URL + file
            except:
                file = self.attachments.all()[0]
                file = file.file.url
            return mark_safe(f'<video src="{file}" controls preload="metadata"></video><br><a href="{file}">Download video</a>')

    objects_unfiltered = models.Manager()
    objects_include_private = PrivateRecordManager()
    objects = PublicActiveRecordManager()

class Photo(LibraryItem):
    position = models.PositiveSmallIntegerField(null=True, blank=True, db_index=True, default=1)
    objects_unfiltered = models.Manager()
    objects_include_private = PrivateRecordManager()
    objects = PublicActiveRecordManager()

class ActivatedSpace(models.Model):
    space = models.ForeignKey("ReferenceSpace", on_delete=models.CASCADE, related_name="activated")
    part_of_project = models.ForeignKey(Project, on_delete=models.CASCADE)
    slug = models.CharField(max_length=255, db_index=True)

    def __str__(self):
        return self.space.name

    def get_absolute_url(self):
        return reverse("data:dashboard", args=[self.slug])

    def save(self, *args, **kwargs):
        self.slug = slugify(unidecode(self.space.name))
        super().save(*args, **kwargs)

    class Meta:
        unique_together = ["slug", "part_of_project"]
        ordering = ["space__name"]

class Dataset(LibraryItem):
    data_formats = models.ManyToManyField(Tag, blank=True, related_name="library_datasets", limit_choices_to={"parent_tag_id": 786})
    data_year_start = models.IntegerField(null=True, blank=True)
    data_year_end = models.IntegerField(null=True, blank=True)
    data_interval = models.CharField(max_length=50, null=True, blank=True)
    update_frequency = models.CharField(max_length=50, null=True, blank=True)
    has_api = models.BooleanField(default=True, db_index=True)
    size = models.IntegerField(null=True, blank=True, help_text="Size in MB")
    activities = models.ManyToManyField("Activity", blank=True)

    objects_unfiltered = models.Manager()
    objects_include_private = PrivateRecordManager()
    objects = PublicActiveRecordManager()

class DataPortal(LibraryItem):

    class Software(models.IntegerChoices):
        CKAN = 1, "CKAN"
        DKAN = 2, "DKAN"
        JUNAR = 3, "Junar"
        ODS = 4, "OpenDataSoft"
        SIXCMS = 5, "sixcms"
        SOCRATA = 6, "Socrata"
        TERRA = 7, "terraCatalogue"
        CUSTOM = 8, "Custom / inhouse implementation"
        OTHER = 9, "Other platform"
        ARCGIS = 10, "ArcGIS Open Data"

    software = models.IntegerField(choices=Software.choices, null=True, blank=True)
    has_api = models.BooleanField(default=True, db_index=True)

    objects_unfiltered = models.Manager()
    objects_include_private = PrivateRecordManager()
    objects = PublicActiveRecordManager()


class Course(Record):
    slug = models.CharField(max_length=255, null=True)
    faq = models.TextField(null=True, blank=True)

    def save(self, *args, **kwargs):
        self.slug = slugify(unidecode(self.name))
        super().save(*args, **kwargs)

    def get_absolute_url(self):
        return reverse("education:course", args=[self.slug])

    def __str__(self):
        return self.name

    def students(self):
        return RecordRelationship.objects.filter(record_child=self, relationship_id=12)

    def recent_students(self):
        # Students who signed up in the last 90 days
        next_week = datetime.datetime.now() - datetime.timedelta(days=90)
        return RecordRelationship.objects.filter(record_child=self, relationship_id=12)

class CourseModule(Record):
    part_of_course = models.ForeignKey(Course, on_delete=models.CASCADE, related_name="modules")

    def get_absolute_url(self):
        return reverse("education:module", args=[self.part_of_course.slug, self.id])

    def __str__(self):
        return self.name

    class Meta:
        ordering = ["name"]

class CourseQuestion(models.Model):
    question = models.CharField(max_length=255)
    module = models.ForeignKey(CourseModule, on_delete=models.CASCADE, related_name="questions")
    answer = models.ForeignKey("CourseQuestionAnswer", on_delete=models.CASCADE, null=True, blank=True)
    position = models.PositiveSmallIntegerField(db_index=True, null=True, blank=True)

    def __str__(self):
        return self.question

    class Meta:
        ordering = ["position"]

class CourseQuestionAnswer(models.Model):
    question = models.ForeignKey(CourseQuestion, on_delete=models.CASCADE, related_name="answers")
    answer = models.CharField(max_length=255)

    def __str__(self):
        return self.answer

class CourseContent(Record):
    class Type(models.IntegerChoices):
        VIDEO = 1, "Video"
        TEXT = 2, "Text"
        EXERCISE = 3, "Exercise"

    type = models.IntegerField(choices=Type.choices, db_index=True, default=1)
    video = models.ForeignKey(Video, on_delete=models.CASCADE, null=True, blank=True)
    module = models.ForeignKey(CourseModule, on_delete=models.CASCADE, related_name="content")
    position = models.PositiveSmallIntegerField(db_index=True, null=True, blank=True)

    class Meta:
        ordering = ["position"]

#class MOOCModuleQuestion(models.Model):
#    module = models.ForeignKey(MOOCModule, on_delete=models.CASCADE, related_name="questions")
#    question = models.ForeignKey(MOOCQuestion, on_delete=models.CASCADE)
#    position = models.PositiveSmallIntegerField(db_index=True, null=True, blank=True)
#    date_created = models.DateTimeField(auto_now_add=True)
#
#    def __str__(self):
#        return self.module.name + " - " + self.question.question
#
#    class Meta:
#        ordering = ["position"]
#
#class MOOCVideo(models.Model):
#    video = models.ForeignKey(Video, on_delete=models.CASCADE)
#    module = models.ForeignKey(MOOCModule, on_delete=models.CASCADE)
#    date_created = models.DateTimeField(auto_now_add=True)
#
#    def __str__(self):
#        return self.module.name + " - " + self.video.video_site + " - " + self.video.url
#
#class MOOCAnswer(models.Model):
#    question = models.ForeignKey(MOOCQuestion, on_delete=models.CASCADE)
#    answer = models.CharField(max_length=255)
#    date_created = models.DateTimeField(auto_now_add=True)
#
#    def __str__(self):
#        return self.answer
#
#class MOOCProgress(models.Model):
#    video = models.ForeignKey(MOOCVideo, on_delete=models.CASCADE)
#    module = models.ForeignKey(MOOCModule, on_delete=models.CASCADE)
#    user = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE)
#    date_created = models.DateTimeField(auto_now_add=True)
#
#    def __str__(self):
#        return self.module.name
#
#class MOOCQuizAnswers(models.Model):
#    mooc = models.ForeignKey(MOOC, on_delete=models.CASCADE)
#    question = models.ForeignKey(MOOCQuestion, on_delete=models.CASCADE)
#    answer = models.ForeignKey(MOOCAnswer, on_delete=models.CASCADE)
#    user = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE)
#    date_created = models.DateTimeField(auto_now_add=True)
#
#    def __str__(self):
#        return self.mooc.name

class WorkActivity(models.Model):

    class WorkType(models.IntegerChoices):
        CREATE = 1, "Creating"
        UPLOAD = 2, "Uploading"
        REVIEW = 3, "Reviewing"
        CURATE = 4, "Curating"
        SHARE = 5, "Sharing"
        PARTICIPATE = 6, "Participating"
        LEARN = 7, "Learning"
        ADMIN = 8, "Administering"
        PROGRAM = 9, "Programming"
        DESIGN = 10, "Designing"
        COMMS = 11, "Communicating"

    type = models.IntegerField(choices=WorkType.choices, db_index=True)
    name = models.CharField(max_length=255)
    instructions = models.TextField(null=True, blank=True)
    default_project = models.ForeignKey(Project, on_delete=models.CASCADE, null=True, blank=True)
    points = models.PositiveSmallIntegerField(null=True, blank=True)
    url = models.URLField(null=True, blank=True, help_text="Is there a specific link a user could go to in order to work on this task? If so, put it here")

    def __str__(self):
        return self.name

    class Meta:
        verbose_name_plural = "work activities"
        ordering = ["name"]

class Work(Record):

    class WorkStatus(models.IntegerChoices):
        OPEN = 1, "Open"
        COMPLETED = 2, "Completed"
        DISCARDED = 3, "Discarded"
        ONHOLD = 4, "On Hold"
        PROGRESS = 5, "In Progress"

    class WorkPriority(models.IntegerChoices):
        LOW = 1, "Low"
        MEDIUM = 2, "Medium"
        HIGH = 3, "High"

    status = models.IntegerField(choices=WorkStatus.choices, db_index=True, default=1)
    priority = models.IntegerField(choices=WorkPriority.choices, db_index=True, default=2)
    part_of_project = models.ForeignKey(Project, on_delete=models.CASCADE, null=True, blank=True)
    workactivity = models.ForeignKey(WorkActivity, on_delete=models.CASCADE, null=True, blank=True)
    related_to = models.ForeignKey(Record, on_delete=models.CASCADE, null=True, blank=True, related_name="my_work")
    assigned_to = models.ForeignKey(People, on_delete=models.CASCADE, null=True, blank=True)
    url = models.URLField(null=True, blank=True, help_text="Is there a specific link a user could go to in order to work on this task? If so, put it here")
    last_update = models.ForeignKey(Message, on_delete=models.SET_NULL, null=True, blank=True)

    def __str__(self):
        return self.name if self.name else self.workactivity.name

    def get_status(self):
        css = {
            1: "font-weight-bold",
            2: "text-success",
            3: "text-muted",
            4: "text-muted",
            5: "text-warning",
        }
        c = css[self.status]
        return mark_safe("<span class='" + c + "'>" + self.get_status_display() + "</span>")

    class Meta:
        verbose_name_plural = "work items"

class WorkSprint(Record):

    start_date = models.DateTimeField()
    end_date = models.DateTimeField(null=True, blank=True)
    projects = models.ManyToManyField(Project, blank=True)
    work_tag = models.ForeignKey(Tag, on_delete=models.CASCADE, null=True, blank=True)

    objects_unfiltered = models.Manager()
    objects_include_private = PrivateRecordManager()
    objects = PublicActiveRecordManager()

    def get_dates(self):
        return get_date_range(self.start_date, self.end_date)

    def get_status(self):
        try:
            today = timezone.now()
            if self.end_date < today:
                return "finished"
            elif self.start_date <= today and self.end_date >= today:
                return "active"
            else:
                return "upcoming"
        except:
            return "upcoming"

    class Meta:
        ordering = ["-start_date"]

class Badge(models.Model):

    class BadgeType(models.IntegerChoices):
        BRONZE = 1, "Bronze"
        SILVER = 2, "Silver"
        GOLD = 3, "Gold"

    type = models.IntegerField(choices=BadgeType.choices, db_index=True)
    code = models.CharField(max_length=20, null=True, blank=True, db_index=True, help_text="Do not change, this is used in the code to verify if people have the right permission level")
    name = models.CharField(max_length=255)
    description = models.CharField(max_length=255)
    projects = models.ManyToManyField(Project, blank=True)
    worktype = models.ManyToManyField(WorkActivity, blank=True) 
    required_quantity = models.PositiveSmallIntegerField(null=True, blank=True)
   
    def __str__(self):
        return self.name

    class Meta:
        ordering = ["code", "type"]

#
#
#
# STAFDB TABLES
#
#
#

# The geocode scheme defines a particular standard, for instance 3166-1 or the South African postal code system
class GeocodeScheme(Record):
    url = models.URLField(null=True, blank=True)
    coverage = models.ForeignKey("ReferenceSpace", on_delete=models.SET_NULL, null=True, blank=True)
    is_comprehensive = models.BooleanField(default=True, db_index=True)
    icon = models.CharField(max_length=50, null=True, blank=True) # Web field

    class Type(models.IntegerChoices):
        SUBDIVISION = 1, "National subdivisions"
        SECTOR = 2, "Sectoral infrastructure"
        AREAS = 3, "Administrative areas"

    type = models.IntegerField(choices=Type.choices, db_index=True, default=3)

    objects_unfiltered = models.Manager()
    objects_include_private = PrivateRecordManager()
    objects = PublicActiveRecordManager()

    def __str__(self):
        return self.name

    def get_absolute_url(self):
        return reverse("staf:geocode", args=[self.id])

    class Meta:
        db_table = "stafdb_geocode_scheme"
        ordering = ["name"]

# Lists all the different levels within the system. Could be a single level (e.g. Postal Code), but it 
# could also include various levels, e.g.: Country > Province > City
# Depth should start at 0 and go up from there
class Geocode(Record):
    scheme = models.ForeignKey(GeocodeScheme, on_delete=models.CASCADE, related_name="geocodes")
    depth = models.PositiveSmallIntegerField()

    objects_unfiltered = models.Manager()
    objects_include_private = PrivateRecordManager()
    objects = PublicActiveRecordManager()

    def __str__(self):
        return self.name

    class Meta:
        db_table = "stafdb_geocode"
        ordering = ["depth", "pk"]

# The reference space, for instance the country "South Africa", the city "Cape Town", or the postal code 8000
class ReferenceSpace(Record):
    slug = models.CharField(max_length=255, null=True)
    location = models.ForeignKey("ReferenceSpaceLocation", on_delete=models.SET_NULL, null=True, blank=True)
    geocodes = models.ManyToManyField(Geocode, through="ReferenceSpaceGeocode")

    def __str__(self):
        return self.name

    def save(self, *args, **kwargs):
        self.slug = slugify(unidecode(self.name))
        super().save(*args, **kwargs)

    @property
    def is_city(self):
        #check = self.geocodes.filter(id=123)
        check = self.geocodes.filter(name="Urban").exists()
        return True if check else False

    @property
    def is_island(self):
        #check = self.geocodes.filter(id=123)
        check = self.geocodes.filter(name="Island").exists()
        return True if check else False

    def photo(self):
        from core.models import Photo
        try:
            return Photo.objects.filter(spaces=self, is_deleted=False).order_by("position")[0]
        except:
            return Photo.objects.get(pk=33476)

    class Meta:
        db_table = "stafdb_referencespace"
        ordering = ["name"]

class ReferenceSpaceLocation(models.Model):
    space = models.ForeignKey(ReferenceSpace, on_delete=models.CASCADE)
    description = models.TextField(null=True, blank=True)
    start = models.DateField(null=True, blank=True, db_index=True)
    end = models.DateField(null=True, blank=True, db_index=True)
    geometry = models.GeometryField()
    is_deleted = models.BooleanField(default=False, db_index=True)

    def __str__(self):
        return "Location for " + self.space.name

    class Meta:
        db_table = "stafdb_referencespace_location"
        ordering = ["-start"]

class ReferenceSpaceGeocode(models.Model):
    geocode = models.ForeignKey(Geocode, on_delete=models.CASCADE)
    space = models.ForeignKey(ReferenceSpace, on_delete=models.CASCADE)
    identifier = models.CharField(max_length=255, db_index=True, null=True, blank=True)

    class Meta:
        db_table = "stafdb_referencespace_geocode"

class ActivityCatalog(Record):
    url = models.URLField(null=True, blank=True)
    original_file = models.FileField(null=True, blank=True, upload_to="activity_catalogs")

    def __str__(self):
        return self.name

    class Meta:
        db_table = "stafdb_activitycatalog"
        verbose_name_plural = "activity catalogs"

class Activity(Record):
    catalog = models.ForeignKey(ActivityCatalog, on_delete=models.CASCADE)
    code = models.CharField(max_length=255, null=True, blank=True, db_index=True)
    parent = models.ForeignKey("self", on_delete=models.CASCADE, null=True, blank=True, related_name="children")
    is_separator = models.BooleanField()
    def __str__(self):
        if self.code:
            return self.code + " - " + self.name
        else:
            return self.name

    class Meta:
        db_table = "stafdb_activity"
        verbose_name_plural = "activities"

# The Flow Diagram describes a system (e.g. the Water sector) and describes the life-cycle based on 
# the processes that take place within it (e.g. Water collection > Water treatment > Use > Wastewater treatment)
class FlowDiagram(Record):
    icon = models.CharField(max_length=50, null=True, blank=True, help_text="Only include the icon name, not fa- classes --- see https://fontawesome.com/icons?d=gallery")

    def get_absolute_url(self):
        return reverse("staf:flowdiagram", args=[self.id])

    def __str__(self):
        return self.name

    class Meta:
        db_table = "stafdb_flowdiagram"

    objects_unfiltered = models.Manager()
    objects_include_private = PrivateRecordManager()
    objects = PublicActiveRecordManager()

class FlowBlocks(models.Model):
    diagram = models.ForeignKey(FlowDiagram, on_delete=models.CASCADE, related_name="blocks")
    origin = models.ForeignKey(Activity, on_delete=models.CASCADE, related_name="blocks_from")
    origin_label = models.CharField(max_length=255, null=True, blank=True)
    destination = models.ForeignKey(Activity, on_delete=models.CASCADE, related_name="blocks_to")
    destination_label = models.CharField(max_length=255, null=True, blank=True)
    description = models.TextField(null=True, blank=True)

    def __str__(self):
        return self.description if self.description else self.origin.name + "  " + self.destination.name

    def get_destination(self):
        return self.destination_label if self.destination_label else self.destination.name

    def get_origin(self):
        return self.origin_label if self.origin_label else self.origin.name

    def get_destination_slug(self):
        return slugify(self.destination_label) if self.destination_label else slugify(self.destination.name)

    def get_origin_slug(self):
        return slugify(self.origin_label) if self.origin_label else slugify(self.origin.name)

    class Meta:
        db_table = "stafdb_flowblocks"

class MaterialCatalog(Record):
    url = models.CharField(max_length=255, null=True, blank=True)
    original_file = models.FileField(null=True, blank=True, upload_to="material_catalogs")

    def __str__(self):
        return self.name

    class Meta:
        db_table = "stafdb_materialcatalog"

class MaterialType(models.IntegerChoices):
    MASS = 1, "Mass"
    VOLUME = 2, "Volume"
    COUNT = 3, "Count"
    AREA = 4, "Area"
    ENERGY = 5, "Energy"
    LENGTH = 6, "Length"
    FRACTION = 7, "Fraction"
    OTHER = 99, "Other"

class Material(Record):
    code = models.CharField(max_length=255, null=True, blank=True, db_index=True)
    parent = models.ForeignKey("self", on_delete=models.CASCADE, null=True, blank=True, related_name="children")
    catalog = models.ForeignKey(MaterialCatalog, on_delete=models.CASCADE, blank=True, null=True, related_name="content")
    #is_separator = models.BooleanField()
    measurement_type = models.IntegerField(choices=MaterialType.choices, db_index=True, blank=True, null=True, default=1)
    icon = models.CharField(max_length=50, null=True, blank=True, help_text="Only include the icon name, not fa- classes --- see https://fontawesome.com/icons?d=gallery")

    def __str__(self):
        if self.code:
            return self.code + " - " + self.name
        else:
            return self.name

    class Meta:
        db_table = "stafdb_material"

class Unit(models.Model):
    name = models.CharField(max_length=255)
    symbol = models.CharField(max_length=255)
    description = models.TextField(null=True, blank=True)
    type = models.IntegerField(choices=MaterialType.choices, db_index=True, default=99)
    multiplication_factor = models.FloatField(null=True, blank=True, help_text="By which factor should we multiply this to get a quantity in the default unit for this type of measurement?")

    def __str__(self):
        return self.name

class MaterialDemand(Record):
    material_type = models.ForeignKey(Material, on_delete=models.CASCADE)
    quantity = models.FloatField()
    unit = models.ForeignKey(Unit, on_delete=models.CASCADE)
    start_date = models.DateField()
    end_date = models.DateField()
    owner = models.ForeignKey(Record, on_delete=models.CASCADE, related_name="demand")

    def __str__(self):
        return self.material_type.name

    def type(self):
        return "supply" if self.quantity < 0 else "demand"

    def absolute_quantity(self):
        return self.quantity*-1 if self.quantity < 0 else self.quantity

    class Meta:
        ordering = ["start_date"]

class Sector(Record):
    icon = models.CharField(max_length=255, null=True, blank=True)
    photo = models.ForeignKey(Photo, on_delete=models.SET_NULL, null=True, blank=True)
    slug = models.SlugField(max_length=255)
    activities = models.ManyToManyField(Activity, db_table="stafdb_sector_activities")

    def __str__(self):
        return self.name

    class Meta:
        db_table = "stafdb_sector"

    #def spaces(self):
    #    return ReferenceSpaceType.objects.filter(processes__in=self.processes.all())
    #def datasets(self):
    #    return DatasetType.objects.filter(Q(origin_process__in=self.processes.all()) | Q(destination_process__in=self.processes.all()))

class UploadSession(Record):
    uploader = models.ForeignKey(People, on_delete=models.CASCADE)
    uuid = models.UUIDField(default=uuid.uuid4, editable=False)
    part_of_project = models.ForeignKey(Project, on_delete=models.SET_NULL, null=True, blank=True)
    TYPE = (
        ("shapefile", "Shapefile"),
        ("flowdata", "Material flow data"),
        ("stockdata", "Material stock data"),
    )
    type = models.CharField(max_length=20, choices=TYPE)

    def __str__(self):
        return self.name

    class Meta:
        db_table = "stafdb_uploadsession"

class UploadFile(models.Model):
    session = models.ForeignKey(UploadSession, on_delete=models.CASCADE, related_name="files")
    file = models.FileField(upload_to=upload_directory, max_length=255)

    def __str__(self):
        return self.file.name

    @property
    def filename(self):
        return os.path.basename(self.file.name)

    @property
    def extension(self):
        filename, file_extension = os.path.splitext(str(self.file.name))
        return file_extension.lower()

    class Meta:
        db_table = "stafdb_uploadfile"

class DataArticle(Record):

    class Category(models.IntegerChoices):
        LOCAL_INDUSTRIES = 1, "Local industries"
        RESOURCE_USE = 2, "Resource use"
        MATERIAL_STOCK = 3, "Material stock"
        WASTE = 4, "Waste"

    class SubCategory(models.IntegerChoices):
        MANUFACTURING = 1, "Manufacturing industries"
        EXTRACTIVE = 2, "Extractive industries"
        OTHER = 3, "Other industries"

    class Completion(models.IntegerChoices):
        STUB = 1, "Stub"
        HALF = 2, "Medium article"
        COMPLETE = 3, "Complete article"

    category = models.IntegerField(choices=Category.choices, db_index=True)
    sub_category = models.IntegerField(choices=SubCategory.choices, db_index=True, null=True, blank=True)
    completion = models.IntegerField(choices=Completion.choices)
    part_of_project = models.ForeignKey(Project, on_delete=models.CASCADE)

    objects_unfiltered = models.Manager()
    objects_include_private = PrivateRecordManager()
    objects = PublicActiveRecordManager()

# Need to remove this (and from stafdb models) when resetting migrations
def shapefile_directory():
    pass

class Chat(models.Model):
    channel = models.ForeignKey(Record, on_delete=models.CASCADE, related_name="chat_channel")
    people = models.ForeignKey(People, on_delete=models.CASCADE, related_name="chat")
    message = models.TextField()
    timestamp = models.DateTimeField(auto_now_add=True)

    def __str__(self):
        return "Chat from " + str(self.people)

    def last_messages(self):
        return Chat.objects.order_by("-timestamp").all()[:50]

class Notification(models.Model):
    record = models.ForeignKey(Record, on_delete=models.CASCADE, related_name="notified_people")
    people = models.ForeignKey(People, on_delete=models.CASCADE, related_name="notifications")
    is_read = models.BooleanField(db_index=True, default=False)

    def __str__(self):
        return str(self.people) + " is notified about " + str(self.record)

class EurostatDB(models.Model):
    title = models.CharField(max_length=2000)
    code = models.CharField(max_length=255)
    type = models.CharField(max_length=255)
    last_update = models.CharField(max_length=255, null=True, blank=True)
    data_start = models.CharField(max_length=255, null=True, blank=True)
    data_end = models.CharField(max_length=255, null=True, blank=True)
    url_overwrite = models.URLField(max_length=255, null=True, blank=True)
    is_reviewed = models.BooleanField(db_index=True, default=False)
    is_approved = models.BooleanField(db_index=True, null=True, blank=True)
    is_denied = models.BooleanField(db_index=True, null=True, blank=True)
    is_duplicate = models.BooleanField(db_index=True, null=True, blank=True, default=False)
    has_no_meta_data = models.BooleanField(db_index=True, null=True, blank=True)
    notes = models.TextField(null=True, blank=True)
    tags = models.ManyToManyField(Tag, blank=True)
    spaces = models.ManyToManyField(ReferenceSpace, blank=True)

    def __str__(self):
        return self.title

from django import forms
class EurostatForm(forms.ModelForm):

    def __init__(self, *args, **kwargs):
        super(EurostatForm, self).__init__(*args, **kwargs)
        self.fields["title"].strip = False

    class Meta:
        model = EurostatDB
        fields = "__all__"

# This is the format to use from now on
# Note that there is a uid primary key, separate from the record_id
# This is must easier to have individual primary key sequences
#
# We should migrate the old stuff at some points
# See https://new.metabolismofcities.org/tasks/33488/
#
#class Dummy(Record):
#    uid = models.AutoField(primary_key=True)
#    record_id = models.OneToOneField(
#        Record, on_delete=models.CASCADE,
#        parent_link=True,
#        primary_key=False,
#    )
#    info = models.CharField(max_length=100)
